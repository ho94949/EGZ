\documentclass[11pt]{article}

\usepackage[top=50mm, bottom=50mm, left=50mm, right=50mm]{geometry}
%\usepackage[a4paper,top=2.5cm,bottom=2.5cm,left=2.5cm,right=2.5cm,marginparwidth=1.75cm]{geometry}
% for adding numbers for lines 
\usepackage{lineno}
%\usepackage{natbib}
%\usepackage{tocbibind}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{float}
\usepackage{subfigure}
\usepackage{multirow}
\usepackage{color}
\usepackage{lineno}
\usepackage{fullpage}
\usepackage[normalem]{ulem} 
\usepackage{makeidx}
\usepackage{xspace}
\usepackage{wrapfig}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\makeindex

\newtheorem{theorem}{Theorem}

\newtheorem{Definition}{Definition}
\newtheorem{corollary}{Corollary}
\newtheorem{Theorem}{Theorem}
\newtheorem{Lemma}{Lemma}
\newtheorem{Notation}{Notation}
\newtheorem{Algorithm}{Algorithm}
\newtheorem{Observation}{Observation}


\newtheorem{lemma}{Lemma}
\newtheorem{claim}{Claim}
\newtheorem{procedure}{Procedure}
\newtheorem{obs}{Observation}

\newcommand{\EGZT}{Erd\H{o}s-Ginzburg-Ziv theorem}





\begin{document}

\title{$\mathcal{O}(n \log n)$ algorithm for finding solutions of Erd≈ës-Ginzburg-Ziv theorem.}
 
\author{Seokhwan Choi, Hanpil Kang, Dongjae Lim}
\maketitle
%\linenumbers
\setcounter{page}{1}

\begin{abstract}
    \EGZT\ is a popular theorem in additive number theory, which states, each set of $2n-1$ integers contains some subset of $n$ elements, with their sum is a multiple of $n$. In this article, we provide an algorithm finding solutions of \EGZT\ in $\mathcal{O}(n \log n)$ time. This is improvement of result of Alberto del Lungo, et al., and first quasi-linear time algorithm finding solutions of \EGZT.
\end{abstract}


\section{\EGZT\ and its proof}

\EGZT\ is stated as follows: \cite{zbMATH03102822}

\begin{theorem} 

For any positive integer $n$, and sequence of $2n-1$ integers ${a}_{1}, {a}_{2}, \cdots, {a}_{2n-1}$, there exists subsequence of length $n$ such that their sum is divisible by $n$.

\end{theorem}

We give an elementary proof of this theorem, based on paper of \cite{zbMATH03102822}. First, we will prove case for prime $n = p$.

Let $k_1, k_2, \cdots, {k}_{2p-1}$ be sorted indices of ${a}_{1}, {a}_{2}, \cdots, {a}_{2p-1}$ according to their remainder divided by p. In other words, $({a}_{{k}_{i}} \bmod p) \le ({a}_{{k}_{i+1}} \bmod p)$ ($1 \le i \le 2p-2$) and $\{{k}_{1}, {k}_{2}, \cdots, {k}_{2p-1}\} = \{1, 2, \cdots, 2p-1\}$.

If index $i$ ($1 \le i \le p-1$) exists such that ${a}_{{k}_{i+1}} \bmod p = {a}_{{k}_{i+p}} \bmod p$, then $\sum_{j={i+1}}^{i+p} {a}_{{k}_{j}} \equiv
\sum_{j={i+1}}^{i+p} ({a}_{{k}_{j}}) \bmod p \equiv p({a}_{i+1} \bmod p) \equiv 0 \pmod p$. So we can choose $a_{k_{i+1}}, a_{k_{i+2}}, \cdots, a_{k_{i+p}}$ as subsequence.

Otherwise, we will define set $S_i$ as follows:

$$ S_i = \begin{cases}
\{(a_{k_1} + a_{k_2} + \cdots + a_{k_p}) \bmod p \} & i = 1 \\
S_{i-1} \cup (S_{i-1} +_p \{d_i\}) & 2 \le i \le p
\end{cases}$$

Here, $A +_n B$ denotes $\{(a+b) \bmod n \mid a \in A, b \in B \}$ and $d_i = a_{k_{i+p-1}} - a_{k_i}$.

Each element of $S_i$ is sum modulo $p$ of subsequnece of length $p$. One element from each of $p$ sets $\{a_{k_1}\}, \{a_{k_2}, a_{k_p}\}, \{a_{k_3}, a_{k_{p+1}} \}, \cdots, \{a_{k_i}, a_{k_{i+p-1}}\}, \{a_{k_{i+1}}\}, \{a_{k_{i+2}}\}, \cdots, \{a_{k_p}\}$ is chosen. We will now prove $|S_i| \ge i$, finally proving that $|S_p| = p$, $0 \in S_p = \{0, 1, \cdots, p-1\}$.

We will use Mathematical Induction on $i$. If $i=1$, $|S_1| = 1 \ge 1$ finishes the proof.

For $i \ge 2$, $S_{i-1} \subset S_i$. So, $|S_{i-1}| \ge i$ gives $|S_i| \ge i$. We only need to consider case $|S_{i-1}| = i-1$. Here, we will consider sum of elements in each set $S_{i-1}$ and $(S_{i-1} +_p \{d_i\})$.

$\sum_{s \in (S_{i-1} +_p \{d_i\})} s - \sum_{s \in S} s \equiv \sum_{s \in S} (s + d_i) - (\sum_{s \in S} s) \equiv |S| \cdot d_i \pmod{p}$.

$0 < |S| = i-1 < p$ and $d_i \not \equiv 0$, so $\sum_{s \in (S_{i-1} +_p \{d_i\})} s \not \equiv \sum_{s \in S} s$, $(S_{i-1} +_p \{d_i\}) \ne S_{i-1}$. Therfore, $|S_i| = |S_{i-1} \cup (S_{i-1} +_p \{d_i\}| = |S_{i-1}| + |S_{i-1} \setminus (S_{i-1} +_p \{d_i\})| \ge (i-1) + 1 = i$.

For composite $n = pq$ ($p, q \ge 2$), We can choose arbitrary subsequence of $p$ of length $2p-1$, choose subsequence of length $q$. We can repeat this process to the integers not chosen as subsequence of length $p$. After $i$'th procedure, $p(2q-i)-1$ integers remains. We repeat this procedure $2p-1$ times, where $q-1$ integers remain and no further subsequence can be chosen.

For sum divided by $p$ of elements in $2q-1$ subsequences, we can choose $b$ elements of length $q$, whose sum is multiple of $q$. By choosing integers of chosen $q$ subsequences, we can select subsequence of length $pq$, whose sum is multiple of $pq$. \qed


\section{Efficient algorithm finding solution of \EGZT.}

By implementing constructive proof directly, we can provide an algorithm finding solutions of \EGZT\ of a sequence. By improving time complexity when $n$ is prime, we can acheive $\mathcal{O}(n \log n)$ time complexity finding solutions. Improvement uses implicit management of set $S_{1}, S_{2}, \cdots, S_{n}$ and modified binary search. This improves result of \cite{DELLUNGO20092658}.

\subsection{Algorithm and correctness}

We will divide cases where $n$ is prime or composite. Here, result of $\bmod$ satisfies $0 \le (a \bmod b) < b$. 

For prime $n = p$, we will manage (arbitrary) $T_i$ where $T_{i-1} \subset T_i \subset S_i$ and $|T_i| = i$. By finding element $t$ such that $t \in T_{i-1}$ but $(t + d_i) \bmod p \not \in T_i$, we can construct $T_i$ as $T_{i-1} \cup \{(s + d_i) \bmod p\}$. By replacing $a_{k_i}$ to $a_{k_{i+p-1}}$ in sequence whose sum modulo $p$ is $s$, we can find sequence of length $p$ whose sum modulo $p$ is $(s+d_i) \bmod p$. This can be recorded efficiently using tree structure.

If $0$ is element of $T_i$, we can find sequence of length $p$ whose sum is multiple of $p$. So, we will construct $T_i$ until $T_i$ has 0 as an element. To find such $s$, we will found $x$ such that $(xd_i \bmod p) \in T_{i-1}$ and $((x+1)d_i \bmod p) \not \in T_{i-1}$. $(xd_i \bmod p)$ will be such $s$. 
For $l$, $h$ with $l < h$ such that $(ld_i \bmod p) \in T_{i-1}$ and $(hd_i \bmod p) \not \in T_{i-1}$, there should be $x$ such that $x \in [l, h)$ $(xd_i \bmod p) \in T_{i-1}$ and $((x+1)d_i \bmod p) \not \in T_{i-1}$. We can find such $m$ using binary search. If $m \in T_{i-1}$, we can limit range as $[m, h)$. If not, we can limit range as $[l, m)$. Repeating this process $\log_2 (h-l)$ times will limit range as single integer.

We know that $(a_{k_1} + a_{k_2} + \cdots + a_{k_p}) \bmod p$ is element of $T_{i-1}$ and $0$ is not. So, we can use $l = ((a_{k_1} + a_{k_2} + \cdots + a_{k_p}) \cdot d_i^{-1}) \bmod p$ and $h = p$.


\begin{procedure} \texttt{EGZ\_prime} calculating solutions of \EGZT\ when $n=p$ is prime.

Input. prime $p$ and array $a$ of $2p-1$ integers.

Output. $0$ or $1$ array $L$ of length $2p-1$, in which $\sum_{i=1}^{2p-1} {L}_{i} = p$ and $p \mid \sum_{i=1}^{2p-1} {a}_{i}{L}_{i}$


\end{procedure}

\begin{algorithmic}[1]

\Function{EGZ\_prime}{$p$, $a$}

    \State $k \gets \Call{SORT}{[1, 2, \cdots, 2p-1], \texttt{key} = x \rightarrow a_x \bmod p}$
    
    \State $L \gets 0$-initialized array of length $2p-1$
    
    \For {$i \gets 1 \cdots p-1$}
        \If {$a_{k_{1+i}} \bmod p = a_{k_{p+i}} \bmod p$}
            \State $L_{k_{1+i}}, L_{k_{2+i}}, \cdots,  L_{k_{p+i}} \gets 1$
            \State \Return $L$
        \EndIf
    \EndFor
    
    \State $s \gets (a_{k_1} + a_{k_2}+ \cdots + a_{k_p}) \bmod p$
    
    \State $T \gets$ \texttt{false}-initialized array, indexed $0 \cdots {p-1}$.
    \State $D \gets$ \texttt{NIL}-initialized array, indexed $0 \cdots {p-1}$.
    
    \State $T_s \gets \texttt{true}$
    
    
    \While {not $T_0$, \textbf{for} $i \gets 1 \cdots p-1$}
        \State $d \gets (A_{k_{p+i}} - A_{k_{1+i}}) \bmod p$
        \State $l \gets (s \times d^{-1}) \bmod p, h \gets p$
        \While {$l+1 \neq h$}
            \State $m \gets \left\lfloor \frac{lo+hi}{2} \right\rfloor$
            \If {$T_{(m \times d) \bmod p}$}
                \State $l \gets m$
            \Else 
                \State $h \gets m$
            \EndIf
        \State $T_{(h \times d) \bmod p} \gets \texttt{true}$
        \State $D_{(h \times d) \bmod p} \gets i$.
        \EndWhile
    \EndWhile
    
    \State $c \gets 0$
    \State $L_1, L_2, \cdots, L_p \gets 1$
    
    \While{$s \neq c$}
        \State $L_{k_{p+D_c}} \gets 1$
        \State $L_{k_{1+D_c}} \gets 0$
        \State $c \gets (c - (a_{k_{p+D_c}}-a_{k_{1+D_c}})) \bmod p $
    \EndWhile
    
    \State \Return L

\EndFunction



\end{algorithmic}


\begin{procedure} \texttt{EGZ\_composite} calculating solutions of \EGZT\ when $n=pq$ is composite.

Input. $p, q \ge 2$ and array $a$ of $2pq-1$ integers.

Output. $0$ or $1$ array $L$ of length $2pq-1$, in which $\sum_{i=1}^{2pq-1} {L}_{i} = pq$ and $ab \mid \sum_{i=1}^{2pq-1} {A}_{i}{L}_{i}$


\end{procedure}

\begin{algorithmic}[1]

\Function{EGZ\_composite}{$p$, $q$, $a$}

    \State $S \gets [1, 2, \cdots, p-1]$
    \State $T \gets $\texttt{NIL}-initialized array of length $2q-1$
    
    \For {$i \gets 1 \cdots 2q-1$}
        \State $S \gets S + [ip, ip+1, \cdots, (i+1)p-1]$
        \State $ret \gets \Call{EGZ}{p, [a_s | s \in S]}$
        \State $T_i \gets [S_j | ret_j = 1], S \gets [S_j | ret_j = 0]$
    \EndFor
    \State $L \gets 0$-initialized array of length $2pq-1$.

    \State $ret \gets \Call{EGZ}{q, \left[\frac{\sum_{t \in T_i} a_t }{p} \mid i = 1, 2, \cdots, 2q-1\right]}$
    \For{$i$ s. t. $ret_i = 1$}
        \For{$j \in T_i$}
            \State $L_j \gets 1$
        \EndFor
    \EndFor
    
    \State \Return $L$
\EndFunction


\end{algorithmic}

\begin{procedure} \texttt{EGZ} calculating solutions of \EGZT.

Input. integer $n$ and array $a$ of $2n-1$ integers.

Output. $0$ or $1$ array $L$ of length $2n-1$, in which $\sum_{i=1}^{2n-1} {L}_{i} = n$ and $n \mid \sum_{i=1}^{2n-1} {a}_{i}{L}_{i}$


\end{procedure}

\begin{algorithmic}[1]

\Function{EGZ}{$n$, $a$}
    \If{$n = 1$}
        \State \Return [1]
    \EndIf
    
    \For {$i=2 \cdots n-1$}
        \If {$i \mid n$}
            \State \Return \Call{EGZ\_composite}{$i, \frac{n}{i}, a$}
        \EndIf
    \EndFor
    
    \State \Return \Call{EGZ\_prime}{$n, a$}
\EndFunction


Procedure 2 and 3 directly implements constructive proof of \EGZT.


\end{algorithmic}

\subsection{Time Complexity}

\begin{theorem}

\texttt{EGZ} has time complexity $\mathcal{O}(n \log n)$.

\end{theorem}

Let's denote time complexity of $\texttt{EGZ}$ function as $T(n)$.

\texttt{EGZ\_composite} has time complexity $T(pq) = (2q-1)T(p) + T(q) + O(pq)$ where $2 \le p \le q$. For some constant $C$, $T(pq) \le (2q-1)T(p) + T(q) + Cpq$. \texttt{EGZ\_prime} has nested loop of 14-27 line and 17-26 line, each repeated $\mathcal{O}(n)$ and $\mathcal{O}(\log n)$ time, resulting total time complexity of $T(n) = \mathcal{O}(n \log n)$ time. For some constant $D$, $T(n) \le D n \log n - C n$.

We will prove $T(n) \le D n \log n - C n$ for $n \ge 2$. We will use Strong Mathematical Induction on $n$. Including base case $n = 2$, it is definition of $C$ and $D$ such that $T(n) \le D n \log n - C n$ for prime $n$. If $n = pq$ with $2 \le p \le q$ is composite, $T(pq) \le (2q-1)T(p) + T(q) + Cpq$.

$\frac{d}{dx} \frac{x \log x}{x-1} = \frac{x - \log x - 1}{(x-1)^2} \ge 0$ For $x \ge 2$, thus $\frac{x \log x}{x-1}$ is increasing, and $(q-1) p \log p - (p-1) q \log q \le 0$. So, $T(pq) = D ( pq \log pq + (q-1) p \log p - (p-1) q \log q) - C (pq + q - p) \le D pq \log pq - C pq$. \qed 





\bibliographystyle{plain}

\bibliography{ref}


\end{document}

